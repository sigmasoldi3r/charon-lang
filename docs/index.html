<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=0.5">
  <!-- Social Media -->
  <meta property="og:title" content="Charon Lang">
  <meta property="og:description" content="Charon is a simple dynamic typed, functional programming language.">
  <meta property="og:image" content="https://raw.githubusercontent.com/sigmasoldi3r/charon-lang/master/app-title-wide.png">
  <meta property="og:url" content="https://sigmasoldi3r.github.io/charon-lang">
  <meta name="twitter:title" content="Charon Lang">
  <meta name="twitter:description" content="Charon is a simple dynamic typed, functional programming language.">
  <meta name="twitter:image" content="https://raw.githubusercontent.com/sigmasoldi3r/charon-lang/master/app.png">
  <meta name="twitter:card" content="https://raw.githubusercontent.com/sigmasoldi3r/charon-lang/master/app-title-wide.png">
  <!-- ------------ -->
  <title>Charon Language</title>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"
    integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
  <link rel="stylesheet" href="theme.css">
  <link rel="stylesheet" href="codemirror.css">
  <link rel="stylesheet" href="charon.css">
</head>

<body>

  <nav class="navbar navbar-expand-lg navbar-dark bg-dark site-navbar fixed-top">
    <a class="navbar-brand" href="http://sigmasoldi3r.github.io/charon-lang">
      <img src="app-title-white.png" class="brand-logo" />
    </a>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav mr-auto">
        <li class="nav-item">
          <a class="nav-link disabled" href="#try">Try Charon online (WIP) <span class="sr-only"></span></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="#LanguageReference">Language reference <span class="sr-only"></span></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/sigmasoldi3r/charon-lang">
            Github
            <span class="sr-only"></span>
          </a>
        </li>
      </ul>
    </div>
  </nav>

  <div id="top" class="container-fluid">
    <div class="row flex-nowrap main-row">

      <!-- Navbar (Side) -->
      <nav class="sidebar bg-charon-light">
        <nav id="contents" class="navbar contents">
          <nav class="nav flex-column">
            <a href="#Introduction" class="nav-link" data-action="sidebar-nav">Introduction</a>
            <a href="#Overview" class="nav-link" data-action="sidebar-nav">Overview</a>
            <a href="#Installation" class="nav-link" data-action="sidebar-nav">Installation</a>
            <nav class="nav flex-column">
              <a href="#InstallWindows" class="nav-link" data-action="sidebar-nav">Windows</a>
              <a href="#InstallOther" class="nav-link" data-action="sidebar-nav">Other</a>
            </nav>
            <a href="#Usage" class="nav-link" data-action="sidebar-nav">Usage</a>
            <nav class="nav flex-column">
              <a href="#UsageCLI" class="nav-link" data-action="sidebar-nav">Command Line</a>
              <a href="#UsageAPI" class="nav-link" data-action="sidebar-nav">API Usage</a>
            </nav>
            <a href="#LanguageReference" class="nav-link" data-action="sidebar-nav">Language Reference</a>
            <nav class="nav flex-column">
              <a href="#Functions" class="nav-link" data-action="sidebar-nav">Functions</a>
              <nav class="nav flex-column">
                <a href="#FunctionPurity" class="nav-link" data-action="sidebar-nav">Function Purity</a>
              </nav>
              <a href="#Strings" class="nav-link" data-action="sidebar-nav">Strings</a>
              <a href="#Lists" class="nav-link" data-action="sidebar-nav">Lists</a>
              <a href="#Tables" class="nav-link" data-action="sidebar-nav">Tables</a>
              <a href="#Atoms" class="nav-link" data-action="sidebar-nav">Atoms</a>
              <a href="#Objects" class="nav-link" data-action="sidebar-nav">Objects</a>
              <a href="#Comments" class="nav-link" data-action="sidebar-nav">Comments</a>
              <a href="#LexicalScoping" class="nav-link" data-action="sidebar-nav">Lexical Scoping</a>
              <nav class="nav flex-column">
                <a href="#LetBinding" class="nav-link" data-action="sidebar-nav">Let Binding</a>
                <a href="#DefBinding" class="nav-link" data-action="sidebar-nav">Def Binding</a>
              </nav>
              <a href="#IfElseAndWhen" class="nav-link" data-action="sidebar-nav">If, else and when expressions</a>
              <a href="#LoopsAndRecursion" class="nav-link" data-action="sidebar-nav">Loops and recursion</a>
              <a href="#Operators" class="nav-link" data-action="sidebar-nav">Operators</a>
              <a href="#ExistentialChecks" class="nav-link" data-action="sidebar-nav">Existential checks and null
                coalescence</a>
              <a href="#AccessIdiom" class="nav-link" data-action="sidebar-nav">Field access idiom</a>
              <a href="#TryCatchThrow" class="nav-link" data-action="sidebar-nav">Try, catch and throw</a>
              <a href="#Modules" class="nav-link" data-action="sidebar-nav">Modules</a>
              <a href="#Resources" class="nav-link" data-action="sidebar-nav">Resources</a>
            </nav>
          </nav>
        </nav>
      </nav>

      <!-- Body -->
      <main class="main">
        <header class="d-none d-lg-block wide-title">
          <p class="title-logo">
            <img src="app-title.png" />
          </p>
        </header>
        <section id="Introduction">
          <p>
            <strong>
              Charon is a lisp-like, simple language that compiles to
              <a href="https://www.lua.org/">Lua</a>.
            </strong>
            Lua is a great programming language for embed systems, IoT and
            general purpose scripting. Is widely used, is small and fast. Charon
            is an attempt to take those traits, and provide the programmer with
            a functional-style, more robust and with a touch of LISP
            programming.
          </p>
          <p>
            Charon only needs a small runtime for new types and functions, which
            also can be embed. The key of Charon development is to maintain
            always a strict interoperability with Lua systems, so existing
            codebase can be maintained, and binding code is easier to write.
          </p>
          <p>
            Currently, Charon is under <strong>heavy development,</strong> and
            many aspects have to be defined yet.
          </p>
          <h4>
            Latest version
          </h4>
          <p>
            <a aria-label="Release Badge" href="https://github.com/sigmasoldi3r/charon-lang/releases">
              <img alt="Release Badge"
                src="https://img.shields.io/github/v/release/sigmasoldi3r/charon-lang?include_prereleases&style=flat-square">
            </a>
          </p>
        </section>
        <section id="Overview">
          <h2>Overview</h2>
          <!-- Not true anymore. -->
          <!-- <p>
            Charon on the left, and the Lua result on the right.
          </p> -->
          <em>
            Currently, the produced code is ugly and spans less lines. This will
            change in future releases.
          </em>
          <aside class="code-example container-fluid">
            <div class="row">
              <textarea class="col-sm-12 editor-panel" id="overview_editor-crn">; Simple matching:
(let [val :b]
  (println! "when " val " = "
    (when val
      :a "Is A!"
      :b "Is B!"
      :c "Is C!"
      _ "Unexpected case.")))

; Tail recursion fibbonacci
(def fib
  (fn [n a? b?]
      (let [a (or? a? 0)
            b (or? b? 1)]
        (if (= n 0) a
          (if (= n 1) b
            (#' (- n 1) b (+ a b)))))))

; Using it like:
(let [n 9]
  (println! (str "fib(" n ") = " (fib 9))))

; For loop, for side-effects (Sometimes you need 'em).
; Numeric for like this one is optimized away as a normal for
(for [i (range 0 10)]
  (println! (str "i = " i)))

; Other sources of iterable components are transformed to pairs:
(for [v [1 2 3 4]]
  (println! (str "v = " v)))

(defn double [x]
  (* x 2))

; Lists
(def doubles
  (list/map [1 2 3 4] double))

(def triples
  (list/map [1 2 3 4]
    (fn [x]
      (* x 3))))

; Do blocks!
(if true
  (do
    (println! "Thing one")
    (println! "Thing two..."))
  (println! "This is part of the 'else'"))

; Somewhat threading macros
(println! "Result:"
  (-> 2
    (+ 4)
    (* 8)))
    
(declare :pure something)

; Try catch!
(try (something)
  (catch [err]
    (println! "Error! " err)))

; For sake of optimization, instead of reducing functions, arithmetics are
; expanded to their binary operator counterparts.
(println! "Arithmetic expansion! "
  (+ (- 2 5 6) 1 2 3 4 5 (* 1 2 6 8)))</textarea>
              <!-- <div class="col-sm-6 editor-panel" id="overview_editor-lua"></div> -->
            </div>
          </aside>
        </section>
        <section id="Installation">
          <h2>Installation</h2>
          <p>
            Installation methods are being improved right now, nothing is stable
            yet, so expect this to change in the future.
          </p>
          <h3 id="InstallWindows">Windows</h3>
          <p>
            Right now installing Charon for Windows is as simple as downloading
            the binaries of the latest build, plus registering it's location to
            the path.
            You can download them at the
            <a href="https://github.com/sigmasoldi3r/charon-lang/releases">
              releases page.
            </a>
          </p>
          <h3 id="InstallOther">Other</h3>
          <p>
            No packages are distributed yet for other OSes, so the best solution
            is to build from source.
          </p>
          <blockquote class="uneditable-code-block">
            <pre><code class="language-bash">git clone https://github.com/sigmasoldi3r/charon-lang.git</code></pre>
          </blockquote>
          <p>
            After that, you can just run, in case of you having <strong>
              Yarn</strong>:
          </p>
          <blockquote class="uneditable-code-block">
            <pre><code class="language-bash">yarn install && yarn build && yarn dist</code></pre>
          </blockquote>
          <p>
            After that, you can just run, in case of you using <strong>
              npm</strong>:
          </p>
          <blockquote class="uneditable-code-block">
            <pre><code class="language-bash">npm install && npm run build && npm run dist</code></pre>
          </blockquote>
          <p>
            Remember to add the binaries to your path, the last command will
            generate them on the <code>dist/</code> folder. If you can't or
            don't want to generate binaries, you can just use the produced
            Javascript file.
          </p>
        </section>
        <section id="Usage">
          <h2>Usage</h2>
          <h3 id="UsageCLI">Command Line</h3>
          If the compiler is installed, you should have access to the command
          <code>charon</code>, which can compile <code>.crn</code> files into
          <code>.lua</code> files. At this moment, no REPL is available to test
          charon directly. <code>charon</code> command options are:
          <table>
            <thead>
              <tr>
                <th>Option</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              Options:
              <tr>
                <td><code>--help</code></td>
                <td>Show help</td>
              </tr>
              <tr>
                <td><code>--output, -o</code></td>
                <td>Output file, optional.</td>
              </tr>
              <tr>
                <td><code>--embed-runtime, -e</code></td>
                <td>Embeds the runtime instead of requiring it. Use for
                  standalone environments.</td>
              </tr>
              <tr>
                <td><code>--extract-runtime, -x</code></td>
                <td>Extracts the runtime to make it available in your
                  local environment.</td>
              </tr>
              <tr>
                <td><code>--global-export, -g</code></td>
                <td>Treats all exported modules as global symbols,
                  including charon runtime.</td>
              </tr>
              <tr>
                <td><code>--no-runtime, -n</code></td>
                <td>Makes compiled modules not require charon runtime
                  explicitly.</td>
              </tr>
              <tr>
                <td><code>--variadic-closures, -s</code>&nbsp;</td>
                <td>Makes all immediate closures variadic (if, do and
                  such blocks).</td>
              </tr>
              <tr>
                <td><code>--type, -t</code></td>
                <td>Compilation mode, will tell how the file is produced.
                  CURRENTLY SUPPORTS MODULE ONLY!</td>
              </tr>
              <tr>
                <td><code>--config, -c</code></td>
                <td>Configuration file for batch compile of projects. NOT
                  USED CURRENTLY.</td>
              </tr>
              <tr>
                <td><code>--version</code></td>
                <td>Show version number</td>
              </tr>
            </tbody>
          </table>
          <h4>Example</h4>
          <p>
            Compile your main script <code>main.crn</code> into a Lua script:
            <code>charon main.crn</code>
          </p>
          <h3 id="UsageAPI">API Usage</h3>
          <p>
            You can use some parts of the compiler as an embed compiler, like in
            web browsers, or in a Node.JS application.
          </p>
          <p>
            There is not much focus on API usage yet, but you can import the
            individual modules from <code>build/src/</code> folder once built.
          </p>
          <p>
            Include <code>build/src/Compiler.js</code> file, (Or in case of a
            Typescript project <code>src/Compiler.ts</code>). Then you can
            simply run the <code>Compiler#compileFile</code> method:
          </p>
          <blockquote class="uneditable-code-block">
            <pre><code>Compiler.compileFile('input.crn', 'output.lua');</code></pre>
          </blockquote>
          <p>
            If you have access to the <strong>Node.JS filesystem</strong>. Else
            you can build your own instance of the compiler, and avoid using the
            static compile method:
          </p>
          <blockquote class="uneditable-code-block">
            <pre><code>
              const instance = Compiler.create({ ...presets.module });
              <br/>
              &nbsp;const out = instance.compile('input source', 'source name');
            </code></pre>
          </blockquote>
        </section>
        <section id="LanguageReference">
          <h2>Language Reference</h2>
          <p>
            First of all, <strong>Charon</strong> uses a Lisp-like syntax. If
            you're familiar with any Lisp family language, specially the
            <strong>Clojure</strong> family, it will be easier to understand.
          </p>
          <p>
            This implies that the language uses
            <a href="https://en.wikipedia.org/wiki/Polish_notation">
              Prefix or Polish notation</a>. This translates, in practical
            terms, to the idea that <a href="#NotationExceptions">almost</a>
            every Charon expression will come in a prefix notation, instead of
            infix or postfix, and surrounded by parenthesis.
          </p>
          <p>
            In most languages, binary operators are infix, you tipically do:
            <code>2 + 2</code>. In Charon instead, you would write something
            like: <code>(+ 2 2)</code>. They mean the same thing in two
            different languages.
          </p>
          <p>
            same applies for function calls, almost all languages use postfix
            notation for function calls. You could possibly write:
            <code>myFunc(1, 2)</code>, but remember that no postfix notation is
            used, this includes the call expression, so, in Charon:
            <code>(myFunc 1 2)</code>.
          </p>
          <p id="NotationExceptions">
            One exception is the <strong>member access expressions</strong>,
            which come in infix notation. You are allowed to access unbounded
            elements with <code>this::expression::of::here</code>, and bounded
            with <code>that:other-expression</code>. This will be cleared later
            on.
          </p>
          <!-- FUNCTIONS -->
          <h3 id="Functions">Functions</h3>
          <p>
            Functions in charon can be defined in four ways:
          </p>
          <ul>
            <li>As pure package functions <code>(defn)</code>.</li>
            <li>As impure package functions <code>(defn!)</code>.</li>
            <li>As pure anonymous functions <code>(fn)</code>.</li>
            <li>As impure anonymous functions <code>(fn!)</code>.</li>
          </ul>
          <aside class="code-example container-fluid">
            <div class="row">
              <textarea class="col-sm-12 editor-panel" id="funcs_editor-crn">; Pure functions
(defn my-pure-func [x y z]
  (+ (** x 2) (** y 2) (** z 2)))

; Impure functions
(defn! my-impure-func [x]
  (println! "Hello" x))

; Pure anonymous function
(fn [a b c]
  (+ a b c))

; Impure anonymous function
(fn! [x]
  (println! "Hi" x))</textarea>
              <!-- <div class="col-sm-6 editor-panel" id="funcs_editor-lua"></div> -->
            </div>
          </aside>
          <h4 id="FunctionPurity">Function Purity</h4>
          <p>
            In charon, we can distinguish by two main types of functions: Pure
            and Impure. Pure functions cannot invoke impure ones, but impure can
            invoke pure ones.
          </p>
          <p>
            Pure functions are expected to not have side effects. This makes
            them easier to test, predictable and able to be memoized.
          </p>
          <p>
            However, due to the idea of easy interoperability, and the fact that
            runs close to Lua, most of the time you will have to manipulate the
            state, or call outside functions which are impure (Due to the fact
            that you can't ensure purity).
          </p>
        </section>
        <section id="Strings">
          <h2>Strings</h2>
          <p>
            Like in Lua and other languages, strings can be delimited by the
            double quote character <code>"</code>. In Charon, the single quote
            character <code>'</code> is used as an identifier and other
            constructs, so a single-quoted string is <strong>invalid</strong>.
          </p>
          <aside class="code-example container-fluid">
            <div class="row">
              <textarea class="col-sm-12 editor-panel" id="strings_editor-crn">; Multiline
(def sentence "Here is some long,
multiple lines spanning,
Charon string.

-- Charon docs")</textarea>
            </div>
          </aside>
          <p style="color: darkred;">
            This is a proposed model, the language does not support interpolation
            yet.
          </p>
          <p>
            Also, strings <b>will</b> support new lines, and interpolation by using the
            dollar symbol <code>$var-name</code> or
            <code>$(some "expression")</code>.
          </p>
          <aside class="code-example container-fluid">
            <div class="row">
              <textarea class="col-sm-12 editor-panel" id="strings-interpol_editor-crn">; Interpolation
(def who "World!")
(def quote "Hello $who")
(def sqrt-of-two "Maybe $(/ 577 408) is a good approximation of √2")</textarea>
            </div>
          </aside>
          <p>
            Concatenation of many strings is also possible with the <code>str</code>
            function, which takes all the arguments and joins them into a single
            string. If the argument is not a string, it will attempt to convert it
            to string.
          </p>
          <aside class="code-example container-fluid">
            <div class="row">
              <textarea class="col-sm-12 editor-panel" id="strings-strcat_editor-crn">; Concatenation
(def s "string")
(str "Some " s " pieces, 2 + 2 = " (+ 2 2))</textarea>
            </div>
          </aside>
          <h3 id="Lists">Lists</h3>
          <p>
            List is the basic sequential structure in Charon, and can be defined
            though the list object literal <code>[ ]</code>.
          </p>
          <aside class="code-example container-fluid">
            <div class="row">
              <textarea class="col-sm-12 editor-panel" id="lists_editor-crn">; List's elements are separated by spaces
; Also can contain any sort of object
(def some-list [1 2 3 4 5 "hi" :bob])</textarea>
            </div>
          </aside>
          <p>
            As lists are heterogeneous in type, and <strong>immutable</strong>,
            they can be used as a <i>Tuple</i> type.
          </p>
          <p>
            To extract the nth item of a list, you can use the <strong>tuple access</strong>
            syntax, or the <strong>list access</strong> syntax:
          </p>
          <aside class="code-example container-fluid">
            <div class="row">
              <textarea class="col-sm-12 editor-panel" id="lists-get_editor-crn">; Both translate to the same in the end
(def my-list ["bob" "alice" "john"])
(def first-elem (:1 my-list))
(def second-elem (list/get 2 my-list))

; In let statements, you can use the tuple destructure syntax:
(let [[_ _ third-elem] my-list])</textarea>
            </div>
          </aside>
          <issue number="11"></issue>

          <h3 id="Tables">Tables</h3>
          <p>
            Tables in Charon are what you might now as <i>Maps</i> or <i>Dictionaries</i>
            in other programming languages.
          </p>
          <p>
            Not to be confused with the <strong>Lua's notion of table</strong>,
            which is a similar structure (In the sense that they're both hash
            tables). We diferentiate them in Charon by calling those <strong>
              Objects
            </strong>.
          </p>
          <p>
            Creating a table is done through the table literal <code>{ }</code>,
            which always should contain pairs of key-value elements. In charon,
            is very common the use of <strong>Symbols</strong> as keys, but you
            can use whatever type you want. As Lists, they're heterogeneous.
          </p>
          <aside class="code-example container-fluid">
            <div class="row">
              <textarea class="col-sm-12 editor-panel" id="lists_editor-crn">; The procedure is similar to lists
; Also can contain any sort of data type
(def some-table
  { :hello       "World"
    :this        "is a table"
    :anything    "Can be a key"
    "like me!"   19294
    1549         [1 2 3 4]
    :even-tables { :hi :o }
    :symbols     :can-be-values-too})

; Reading entries can be done in two ways:
; This is the shortest, but only works for symbol keys
(def some-val (:hello some-table))
; Or, for other types of keys, you can use this
(def some-other (table/get "like me!" some-table))</textarea>
            </div>
          </aside>
        </section>
        <p>
          Lacking an even number of entries will result in a compile error.
        </p>
        <issue number="10"></issue>

        <h3 id="Atoms">Atoms</h3>
        <p>
          Atoms are the <i>almost</i> only way of persisting a state in charon.
          Other techniques that obscure data mutations to the program are
          heavily discouraged.
        </p>
        <p>
          An atom is an object that has a mutable state, that you can read and
          write to.
        </p>
        <aside class="code-example container-fluid">
          <div class="row">
            <textarea class="col-sm-12 editor-panel" id="lists_editor-crn">; You define the atom once
(def my-state (atom 0))
; Then you change the state and read it, as many times as you want.
(println! (atom/get my-state))
(atom/reset! my-state 1)
(println! (atom/get my-state))</textarea>
          </div>
        </aside>
        <p>
          All atom related functions, besides the atom creation itself, are
          <strong>impure</strong>, because they involve hidden state
          manipulation.
        </p>
        <p>
          Also, atoms can contain any kind of datatype at any time.
        </p>
        <issue number="12"></issue>

        <h3 id="Objects">Objects</h3>
        <p>
          As mentioned in the Table section, when we talk about <strong>Objects</strong>
          in Charon, we refer to unbound datatypes, with no data methods.
        </p>
        <p>
          <i>Note: There is a planned notion of object or "record" in Charon,
            but the proposal is not stable yet.
          </i>
        </p>
        <p>
          To put it in plain: Objects are any Lua table that is not a known data
          type, like Atoms, Lists or Tables. This exists in order to make the
          program able to define foreign objects used by an external Lua API.
          This also means that all object related functions are <strong>impure</strong>.
        </p>
        <issue number="13"></issue>

        <h3 id="Comments">Comments</h3>
        <p>
          The only way to make a comment in Charon is by using the <code>;</code>
          character. There are no multiline comments.
        </p>
        <aside class="code-example container-fluid">
          <div class="row">
            <textarea class="col-sm-12 editor-panel" id="comment_editor-crn">;;;
; You've been seeing this all over the code!
;;;
(defn sum-me [a b]
  (+ a b)) ; Just sum? Easy</textarea>
          </div>
        </aside>

        <h3 id="LexicalScoping">Lexical Scoping</h3>
        <p>
          There are two ways of declare values: By <code>(let [] ...)</code> and
          by <code>(def ...)</code>. The first binds a local value, while the
          second a global (And exported) one.
        </p>

        <h4 id="LetBinding">Let Binding</h4>
        <p>
          The <strong>let</strong> expression binds to a local scope a set of
          values passed to the binding array. The array always must contain
          pairs of value-names and expressions representing those values.
        </p>
        <aside class="code-example container-fluid">
          <div class="row">
            <textarea class="col-sm-12 editor-panel" id="let1_editor-crn">; This is a local binding
(let [one 1
      two 2]
  (println! "You can see here" one "&" two))
; But outside of the let, one and two does not exist!</textarea>
          </div>
        </aside>
        <p>
          Let, also allows destructuring a <strong>List</strong> object, by
          binding directly it's terms without having to write access by hand:
        </p>
        <aside class="code-example container-fluid">
          <div class="row">
            <textarea class="col-sm-12 editor-panel" id="let2_editor-crn">; Here we can treat this list as a tuple:
(def a-tupl [1 "green" :heavy])

; Destructure by surrounding key names with [ ]
(let [[a b c] a-tupl]
  (println! "Elements of the tuple:" a b c))</textarea>
          </div>
        </aside>

        <h4 id="DefBinding">Def Binding</h4>
        <p>
          Def bindings are also called <strong>global</strong> bindings,
          although they do not declare the variable global for the runtime, they
          are global in a module level.
        </p>
        <p>
          Those are public (Or "Exported"), and importing modules can read them.
          You cannot <strong>declare a global more than once</strong>, doing so
          will result in an error.
        </p>
        <aside class="code-example container-fluid">
          <div class="row">
            <textarea class="col-sm-12 editor-panel" id="def_editor-crn">; This has being used all over the docs:
(def my-global (atom 45))

(defn plus-one []
  (atom/apply! my-global + 1))</textarea>
          </div>
        </aside>

        <h3 id="#IfElseAndWhen">If, else and when expressions</h3>
        <p>
          In Charon, an <i>if</i> condition is an <strong>expression</strong>.
          This means that can be used for conditional assignment, as the result
          of evaluating the <i>if</i> will be either branch.
        </p>
        <p>
          Also the first expression of the <code>(if ...)</code> construct is
          the <code>then</code> part, while the rest the <code>else</code>.
          In the else branch, only the last expression will be returned,
          although all are evaluated.
        </p>
        <p>
          The syntax would be <code>(if boolean then-expr else-1 else-2 ... else-n)</code>.
        </p>
        <aside class="code-example container-fluid">
          <div class="row">
            <textarea class="col-sm-12 editor-panel" id="if_editor-crn">; If is also an expression here
(def color (if valid :green :red))
; This is roughly like typing 'color = valid ? "green" : "red";'

; It can be used for traditional flow control
(if wants-ketchup
  (do
    (prepare-ketchup)
    (serve-ketchup))
  (do
    (prepare)
    (serve)))</textarea>
          </div>
        </aside>
        <p>
          But aside from a simple if, you can make more complex branching
          without nesting if expressions.
        </p>
        <p>
          <code>when</code>, like <code>if</code> is also an expression, and
          the same rules apply. The syntax is roughly
          <code>(when value case-1 expr-1 ... case-n expr-n _ default-expr)</code>.
        </p>
        <p>
          Note that all cases come in pairs. The else or default case in a when
          expression is noted with the <code>_</code> symbol.
        </p>
        <aside class="code-example container-fluid">
          <div class="row">
            <textarea class="col-sm-12 editor-panel" id="when_editor-crn">; When is similar to a switch-case:
(when color
  :red   (println! "Is red!!")
  :green (println! "Ah... the green of the mountains")
  _      (println! "What...?"))

; But when can be used for more complex pattern matching
; Take a tuple like:
(def tpl [1 "a" :b])
; You can use pattern matching like:
(when tpl
  [5 "a"] (println! "Five and A...")
  [_ "a"] (println! "In case you wonder... was A only")
  [_ "b"] (println! "Only B matters")
  _       (println! "Who knows..."))</textarea>
          </div>
        </aside>

        <h3 id="LoopsAndRecursion">Loops and recursion</h3>
        <p>
          In Charon, we assume that you eventually will need some looping for
          side effects. That's because a <code>for</code> expression does not
          return anything, so the only way you really want to use this is for
          side effects, which include our beloved <code>println!</code> function.
        </p>
        <aside class="code-example container-fluid">
          <div class="row">
            <textarea class="col-sm-12 editor-panel" id="loop1_editor-crn">; For loops here act similar to Lua's for
; This would be the classic example of a for that goes from 1 to 100.
(for [i (range 1 100)]
  (println! "i = " i))

; But you can use any sequence-like object:
(for [n [1 2 3 4]] (println! "n = " n))

; Even in pairs!
(for [value key {:a 1 :b 2 :c 3}]
  (println! key " => " value))</textarea>
          </div>
        </aside>
        <p>
          <i>
            The subject of adding a while loop is being discussed in the issue
            <a href="https://github.com/sigmasoldi3r/charon-lang/issues/15">#15</a>
            .
          </i>
        </p>
        <p>
          Other means of more pure looping is the recursion. You could just
          write a tail-recursive function by calling the same function over
          again.
        </p>
        <p>
          This sadly does not work easy with anonymous functions, but for that
          comes the self-recursion trait in to rescue, with <code>#'</code>.
        </p>
        <aside class="code-example container-fluid">
          <div class="row">
            <textarea class="col-sm-12 editor-panel" id="loop1_editor-crn">; Example of self-recursion:
(defn fib [n a b]
  (if (= n 0) a
    (if (= n 1) b
      (#' (- n 1) b (+ a b)))))</textarea>
          </div>
        </aside>
        <p>
          We claim that the use of <code>for</code> loops is tightly related
          with side effects because it cannot produce any result without them.
        </p>
        <p>
          For looping procedures that can produce pure results, use methods like
          <code>list/map</code> or <code>list/reduce</code>.
        </p>

        <h3 id="Operators">Operators</h3>
        <p>
          Charon has an equivalent for most binary operatos, which include the
          typical arithmetic operators like <code>+</code>, <code>-</code>,
          <code>*</code> and <code>/</code>, plus power operator <code>**</code>,
          modulo <code>%</code> and integer division <code>//</code>.
        </p>
        <p>
          Also boolean operators for <code>not</code> (Only accepts one
          argument!), <code>and</code>, <code>or</code>, <code>xor</code>,
          <code>nand</code> and <code>nor</code>.
        </p>
        <p>
          Comparison can be done though <code>=</code>, <code>&lt;&gt;</code>
          (not equal),
          <code>&gt;</code>, <code>&lt;</code>, <code>&lt;=</code> and
          <code>&gt;=</code>
        </p>

        <h3 id="#ExistentialChecks">Existential checks and null coalescence</h3>
        <p>
          In Charon you can pass non-boolean values to the <code>if</code>
          expression, but that can not be used to check for existent or not
          existent values, as <code>unit</code> will translate to
          <code>true</code> but <code>nothing</code> to false.
        </p>
        <p>
          To check if a value is neither <code>unit</code> or <code>nothing</code>
          you check with the function <code>(some? ...)</code>. If for some
          reason you need to distinguish between <strong>unit and nothing</strong>,
          you can do so with <code>(nothing? ...)</code> and <code>(unit? ...)</code>
          functions.
        </p>
        <p>
          Aside, you can use the <code>(or? value? default)</code> function
          which takes a value, and returns it if was something, or returns the
          second argument if was nothing or unit. This function is also known
          as the coalesce operator.
        </p>
        <aside class="code-example container-fluid">
          <div class="row">
            <textarea class="col-sm-12 editor-panel" id="exists_editor-crn">; Existential checks for possibly unit values
(if (some? input)
  (println! "Input is " input)
  (println! "Please, provide imput!"))

; Checks with maps
(def m {:a unit :b 5})

; some? returns false on both :a and :c
(assert
  (=
    (some? (:a m))
    (some? (:c m))))

; But you can differentiate an existing entry with no value
; from one that does not exist:
(assert (nothing? (:c m)))
(assert (unit? (:a m)))

; In case of no value (For either reason)
(def i-am-surely-something
  (or? (:a m) 0))
(def me-too
  (or? (:c m) 0))</textarea>
          </div>
        </aside>

        <h3 href="#AccessIdiom">Field access idiom</h3>
        <p>
          Sometimes, you need to manipulate external Lua objects, like in case
          of native or 3rd party libraries. For those cases, chaining
          function binding and <code>object/get</code> calls gets really tedious
          quickly.
        </p>
        <p>
          For that reason, there is a special form that uses the <code>::</code>
          and <code>:</code> symbols as infix operators in names.
        </p>
        <p>
          The difference between those two, is that the first <code>::</code> is
          what we call an unbound access, which in case of a field, is just a
          reference. But in case of function calls, the function is called
          statically.
        </p>
        <p>
          The second, <code>:</code>, is used only in bound function calls, when
          we need to pass the <code>self</code> argument implicitly. Attempting
          to use this for referncing a field will result in a syntax error.
        </p>
        <aside class="code-example container-fluid">
          <div class="row">
            <textarea class="col-sm-12 editor-panel" id="access_editor-crn">; Object access in case of foreign objects
(my::nested::object::func "yes")
(player::weapon:reload 50) ; Note the last ":"
(println! player::weapon::ammo)</textarea>
          </div>
        </aside>

        <h3 href="#TryCatchThrow">Try, catch and throw</h3>
        <p>
          Error handling in Charon uses the <strong>try-catch</strong>
          structure. However, catching is untyped an you might only have one
          <code>catch</code> per try. <code>throw</code> can throw any value and
          it will be handled by the nearest <code>try</code>.
        </p>
        <aside class="code-example container-fluid">
          <div class="row">
            <textarea class="col-sm-12 editor-panel" id="trycatch_editor-crn">; Classic try-catch
(defn error-prone
  (throw "Indeed"))

(try (error-prone)
  (catch [err]
    (println! "Error found:" err)))</textarea>
          </div>
        </aside>

        <h3 id="Modules">Modules</h3>
        <p>
          Charon has a notion of modules, where each file represents one.
          Modules declare public fields that can be reused in other modules,
          via <code>import</code> or <code>module</code> declaration.
        </p>
        <p>
          Wether you need to declare the module name explicitly or not depends
          on your project needs, take in mind that charon uses the file name
          if no module name is provided explicitly. Although is recommended that
          module and file name matches, sometimes you'll need to override that.
        </p>
        <aside class="code-example container-fluid">
          <div class="row">
            <textarea class="col-sm-12 editor-panel" id="modules_editor-crn">; Modules can be optionally named with:
(module my_module
  [:import lib :from "lib"]) ; This is also optional

; If you don't have explicit module name you can use:
(import lib :from "lib")</textarea>
          </div>
        </aside>

        <h3 id="Resources">Resources</h3>
        <ul>
          <li>
            <a href="https://github.com/sigmasoldi3r/charon-lang">
              Charon on Github
            </a>
          </li>
          <li>
            <a href="https://discord.gg/GuRqctF">
              Charon on Discord
            </a>
          </li>
        </ul>

      </main>

    </div>
  </div>

  <!-- Bootstrap scripts -->
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"
    integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj"
    crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
    integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
    crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"
    integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI"
    crossorigin="anonymous"></script>

  <!-- Editor and other scripts -->
  <script src="codemirror.js"></script>
  <script src="simple.js"></script>
  <script src="lua.js"></script>
  <script src="mode-charon.js"></script>
  <script src="index.js"></script>
</body>

</html>
